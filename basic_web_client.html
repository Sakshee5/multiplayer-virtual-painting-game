<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Color Battle - Virtual Drawing Game</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
      overflow: hidden;
    }
    .header {
      text-align: center;
      padding: 10px;
      background-color: #4CAF50;
      color: white;
      font-size: 24px;
      margin-bottom: 10px;
    }
    .container {
      position: relative;
      width: 100%;
      max-width: 1280px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .video-container {
      position: relative;
      width: 100%;
      max-width: 1280px;
      border: 3px solid #000;
      height: 522px;
    }
    .input_video {
      position: absolute;
      width: 100%;
      height: 100%;
      visibility: hidden;
    }
    .output_canvas {
      position: absolute;
      width: 100%;
      height: 100%;
      border-bottom: none;
    }
    .drawing_canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
    }
    .splash {
      width: 100%;
      max-width: 1280px;
      height: 198px;
      background-image: url('splashh.png');
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center;
      margin-top: -3px;
      border: 3px solid #000;
      border-top: none;
    }
    .status {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 5px;
      border-radius: 5px;
      z-index: 20;
    }
  </style>
</head>

<body>
  <div class="header">
    Color Battle - Virtual Drawing Game
  </div>
  <div class="container">
    <div class="status">DRAW HERE</div>
    <div class="video-container">
      <video class="input_video"></video>
      <canvas class="output_canvas"></canvas>
      <canvas class="drawing_canvas"></canvas>
    </div>
    <div class="splash"></div>
  </div>
</body>

<script type="module">
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');
    const drawingCanvas = document.getElementsByClassName('drawing_canvas')[0];
    const drawingCtx = drawingCanvas.getContext('2d');
    
    // Set the canvas dimensions to match the video dimensions
    canvasElement.width = 1280;
    canvasElement.height = 522;
    drawingCanvas.width = 1280;
    drawingCanvas.height = 522;
    
    // Drawing variables
    let xp = 0;
    let yp = 0;
    const DRAW_COLOR = [255, 0, 0]; // Default color (can be changed later)
    let brushThickness = 25;
    let isDrawing = false;
    
    // Function to check if index finger is up and others are down
    function isIndexFingerUp(landmarks) {
        // Get the y-coordinates of important finger landmarks
        const wristY = landmarks[0].y;
        const indexMCP = landmarks[5].y;
        const indexPIP = landmarks[6].y;
        const indexDIP = landmarks[7].y;
        const indexTip = landmarks[8].y;
        
        const middleMCP = landmarks[9].y;
        const middleTip = landmarks[12].y;
        
        const ringMCP = landmarks[13].y;
        const ringTip = landmarks[16].y;
        
        const pinkyMCP = landmarks[17].y;
        const pinkyTip = landmarks[20].y;
        
        const thumbTip = landmarks[4].y;
        
        // Check if index finger is extended up
        const isIndexUp = indexTip < indexDIP && indexDIP < indexPIP && indexPIP < indexMCP;
        
        // Check if other fingers are closed (tips below MCPs)
        const isMiddleClosed = middleTip > middleMCP;
        const isRingClosed = ringTip > ringMCP;
        const isPinkyClosed = pinkyTip > pinkyMCP;
        
        // For thumb we just check if it's generally higher than the wrist
        // This is a simple approximation, might need refinement
        const isThumbNotUp = thumbTip > wristY;
        
        return isIndexUp && isMiddleClosed && isRingClosed && isPinkyClosed;
    }
    
    function onResults(results) {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      
      // Draw the camera feed with mirrored view consistently
      canvasCtx.translate(canvasElement.width, 0);
      canvasCtx.scale(-1, 1);
      canvasCtx.drawImage(
          results.image, 0, 0, canvasElement.width, canvasElement.height);
      
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        // Draw hand landmarks and connections with smaller, more subtle landmarks
        for (const landmarks of results.multiHandLandmarks) {
          drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS,
                       {color: 'rgba(255, 255, 255, 0.4)', lineWidth: 0.5});
          drawLandmarks(canvasCtx, landmarks, {
            color: 'rgba(255, 255, 255, 0.5)', 
            lineWidth: 0.5,
            radius: (x) => {
              return 2; // Smaller circles for all landmarks
            }
          });
          
          // Check if only index finger is up
          if (isIndexFingerUp(landmarks)) {
            // Drawing mode
            isDrawing = true;
            
            // These coordinates are in the flipped coordinate system
            // Get original landmarks in the flipped coordinate system
            const indexTipX = landmarks[8].x * canvasElement.width;
            const indexTipY = landmarks[8].y * canvasElement.height;
            
            // Draw the colored circle in the flipped coordinate system
            canvasCtx.fillStyle = `rgb(${DRAW_COLOR[0]}, ${DRAW_COLOR[1]}, ${DRAW_COLOR[2]})`;
            canvasCtx.beginPath();
            canvasCtx.arc(indexTipX, indexTipY, 10, 0, 2 * Math.PI);
            canvasCtx.fill();
            
            // Convert to unflipped coordinates for drawing on the canvas
            const x1 = canvasElement.width - indexTipX; // Unflip the x coordinate
            const y1 = indexTipY; // y doesn't need to be flipped
            
            // Handle the drawing points
            if (xp === 0 && yp === 0) {
              xp = x1;
              yp = y1;
            }
            
            // Draw on the separate drawing canvas with consistent coordinates
            drawingCtx.beginPath();
            drawingCtx.moveTo(xp, yp);
            drawingCtx.lineTo(x1, y1);
            drawingCtx.strokeStyle = `rgb(${DRAW_COLOR[0]}, ${DRAW_COLOR[1]}, ${DRAW_COLOR[2]})`;
            drawingCtx.lineWidth = brushThickness;
            drawingCtx.lineCap = 'round';
            drawingCtx.stroke();
            
            xp = x1;
            yp = y1;
          } else {
            // Not drawing
            isDrawing = false;
            xp = 0;
            yp = 0;
          }
        }
      }
      
      canvasCtx.restore();
    }
    
    const hands = new Hands({locateFile: (file) => {
      return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.65,
      minTrackingConfidence: 0.5
    });
    
    hands.onResults(onResults);
    
    const camera = new Camera(videoElement, {
      onFrame: async () => {
        await hands.send({image: videoElement});
      },
      width: 1280,
      height: 720
    });
    
    // Function to clear the drawing canvas
    function clearCanvas() {
      drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    }
    
    // Start the camera
    camera.start();
</script>
</html>