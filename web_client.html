<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Color Battle - Virtual Drawing Game</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background-color: #f0f0f0;
      overflow: hidden;
    }
    .header {
      text-align: center;
      padding: 10px;
      background-color: #4CAF50;
      color: white;
      font-size: 24px;
      margin-bottom: 10px;
    }
    .container {
      position: relative;
      width: 100%;
      max-width: 1280px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .video-container {
      position: relative;
      width: 100%;
      max-width: 1280px;
      border: 3px solid #000;
      height: 522px;
    }
    .input_video {
      position: absolute;
      width: 100%;
      height: 100%;
      visibility: hidden;
    }
    .output_canvas {
      position: absolute;
      width: 100%;
      height: 100%;
      border-bottom: none;
    }
    .drawing_canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
    }
    .splash {
      width: 100%;
      max-width: 1280px;
      height: 198px;
      background-image: url('splashh.png');
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center;
      margin-top: -3px;
      border: 3px solid #000;
      border-top: none;
    }
    .status {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 5px;
      border-radius: 5px;
      z-index: 20;
    }
    .game-info {
      position: absolute;
      top: 10px;
      right: 10px;
      color: white;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 5px;
      border-radius: 5px;
      z-index: 20;
    }
    .countdown {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 120px;
      font-weight: bold;
      color: white;
      text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
      z-index: 30;
      display: none;
    }
    .start-area {
      position: absolute;
      left: 340px;
      top: 300px;
      width: 200px;
      height: 100px;
      border: 3px dashed rgba(255, 255, 255, 0.7);
      border-radius: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-weight: bold;
      font-size: 24px;
      z-index: 15;
    }
    .reset-area {
      position: absolute;
      left: 740px;
      top: 300px;
      width: 200px;
      height: 100px;
      border: 3px dashed rgba(255, 255, 255, 0.7);
      border-radius: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      color: white;
      font-weight: bold;
      font-size: 24px;
      z-index: 15;
      display: none;
    }
    .winner-announcement {
      position: absolute;
      top: 160px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 48px;
      font-weight: bold;
      color: white;
      text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
      z-index: 30;
      display: none;
    }
    .timer {
      position: absolute;
      top: 50px;
      right: 50px;
      font-size: 24px;
      font-weight: bold;
      color: white;
      background-color: rgba(0, 0, 0, 0.6);
      padding: 5px 10px;
      border-radius: 5px;
      z-index: 20;
      display: none;
    }
    .player-scores {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: white;
      font-size: 18px;
      z-index: 20;
    }
  </style>
</head>

<body>
  <div class="header">
    Color Battle - Virtual Drawing Game
  </div>
  <div class="container">
    <div class="status">DRAW HERE</div>
    <div class="game-info">Waiting for connection...</div>
    <div class="video-container">
      <video class="input_video"></video>
      <canvas class="output_canvas"></canvas>
      <canvas class="drawing_canvas"></canvas>
      <div class="countdown" id="countdown"></div>
      <div class="start-area" id="start-area">START</div>
      <div class="reset-area" id="reset-area">RESET</div>
      <div class="winner-announcement" id="winner-announcement"></div>
      <div class="timer" id="timer">Time Left: 60s</div>
      <div class="player-scores" id="player-scores"></div>
    </div>
    <div class="splash"></div>
  </div>

  <!-- Audio elements -->
  <audio id="beepSound" src="countdown_beep.mp3" preload="auto"></audio>
  <audio id="goSound" src="countdown_go.mp3" preload="auto"></audio>
  <audio id="gameplaySound" src="gameplay.mp3" preload="auto" loop></audio>

  <script type="module">
    // DOM Elements
    const videoElement = document.getElementsByClassName('input_video')[0];
    const canvasElement = document.getElementsByClassName('output_canvas')[0];
    const canvasCtx = canvasElement.getContext('2d');
    const drawingCanvas = document.getElementsByClassName('drawing_canvas')[0];
    const drawingCtx = drawingCanvas.getContext('2d');
    const countdownElement = document.getElementById('countdown');
    const startAreaElement = document.getElementById('start-area');
    const resetAreaElement = document.getElementById('reset-area');
    const winnerAnnouncementElement = document.getElementById('winner-announcement');
    const timerElement = document.getElementById('timer');
    const playerScoresElement = document.getElementById('player-scores');
    const gameInfoElement = document.querySelector('.game-info');
    
    // Audio elements
    const beepSound = document.getElementById('beepSound');
    const goSound = document.getElementById('goSound');
    const gameplaySound = document.getElementById('gameplaySound');
    
    // Set the canvas dimensions to match the video dimensions
    canvasElement.width = 1280;
    canvasElement.height = 522;
    drawingCanvas.width = 1280;
    drawingCanvas.height = 522;
    
    // Game state variables
    let gameActive = false;
    let gameReset = false;
    let gameCountdown = false;
    let selfId = null;
    let DRAW_COLOR = [255, 0, 0]; // Default color (will be assigned by server)
    let DRAW_COLOR_TEMP = null; // Temporary color for power-ups
    
    // Drawing variables
    let xp = 0;
    let yp = 0;
    let brushThickness = 25;
    let isDrawing = false;
    
    // Power-ups
    let powerUpsAvailable = [];
    
    // Client data
    let clientData = {};
    
    // WebSocket connection
    const SERVER = "wss://c6eb5fa2-5220-4b94-98c3-1090e48aaa3a-00-9zpw8zj0rka4.spock.replit.dev/";
    let websocket = null;
    
    // Connect to WebSocket server
    function connectWebSocket() {
      websocket = new WebSocket(SERVER);
      
      websocket.onopen = () => {
        console.log("Connected to server");
        gameInfoElement.textContent = "Connected, waiting for color assignment...";
      };
      
      websocket.onclose = (event) => {
        console.log("Disconnected from server:", event.code, event.reason);
        gameInfoElement.textContent = "Connection lost. Reconnecting...";
        setTimeout(connectWebSocket, 3000); // Try to reconnect after 3 seconds
      };
      
      websocket.onerror = (error) => {
        console.error("WebSocket error:", error);
        gameInfoElement.textContent = "Connection error. Reconnecting...";
      };
      
      websocket.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          
          // First message - color assignment
          if (!Array.isArray(data) && !data.hasOwnProperty('type')) {
            DRAW_COLOR = JSON.parse(event.data);
            console.log("Assigned color:", DRAW_COLOR);
            gameInfoElement.textContent = `Your color: RGB(${DRAW_COLOR[0]}, ${DRAW_COLOR[1]}, ${DRAW_COLOR[2]})`;
            return;
          }
          
          // Client list update
          if (data.type === "client_list" && !gameActive && !gameCountdown && !gameReset) {
            clearDrawingCanvas();
            const connectedClients = data.clients;
            selfId = data.self_id;
            
            let i = 40;
            for (const [client, color] of Object.entries(connectedClients)) {
              const clientColor = JSON.parse(color);
              if (client === selfId.toString()) {
                const text = `Connected - YOU: Color (${DRAW_COLOR[0]}, ${DRAW_COLOR[1]}, ${DRAW_COLOR[2]})`;
                drawText(drawingCtx, text, 650, 85, `rgb(${DRAW_COLOR[0]}, ${DRAW_COLOR[1]}, ${DRAW_COLOR[2]})`, 20);
              } else {
                const text = `Connected - Player (${clientColor[0]}, ${clientColor[1]}, ${clientColor[2]})`;
                drawText(drawingCtx, text, 650, 85 + i, `rgb(${clientColor[0]}, ${clientColor[1]}, ${clientColor[2]})`, 20);
                i += 40;
              }
            }
          }
          
          // Countdown
          if (data.type === "countdown") {
            gameActive = false;
            gameCountdown = true;
            const count = data.count;
            
            if (count === "GO") {
              goSound.play();
            } else {
              beepSound.play();
            }
            
            countdownElement.textContent = count;
            countdownElement.style.display = "block";
            clearDrawingCanvas();
            
            // Hide countdown after a short delay
            if (count === "GO") {
              setTimeout(() => {
                countdownElement.style.display = "none";
              }, 1000);
            }
          }
          
          // Game start
          if (data.type === "start") {
            gameplaySound.play();
            clearDrawingCanvas();
            gameActive = true;
            gameReset = false;
            gameCountdown = false;
            countdownElement.style.display = "none";
            startAreaElement.style.display = "none";
            timerElement.style.display = "block";
          }
          
          // Power-up spawn
          if (data.type === "power_up_spawn") {
            powerUpsAvailable.push(data.power_up);
          }
          
          // Game reset
          if (data.type === "reset") {
            gameActive = false;
            gameReset = false;
            clearDrawingCanvas();
            resetAreaElement.style.display = "none";
            startAreaElement.style.display = "flex";
            timerElement.style.display = "none";
            winnerAnnouncementElement.style.display = "none";
            clientData = {};
          }
          
          // Winner announcement
          if (data.type === "winner") {
            gameplaySound.pause();
            gameplaySound.currentTime = 0;
            gameActive = false;
            gameReset = true;
            const winner = data.winner;
            console.log("Winner is", winner);
            
            const winnerColor = JSON.parse(winner);
            winnerAnnouncementElement.textContent = `Winner: Player (${winnerColor[0]}, ${winnerColor[1]}, ${winnerColor[2]})`;
            winnerAnnouncementElement.style.color = `rgb(${winnerColor[0]}, ${winnerColor[1]}, ${winnerColor[2]})`;
            winnerAnnouncementElement.style.display = "block";
            resetAreaElement.style.display = "flex";
          }
          
          // Timer update
          if (data.type === "timer") {
            const timeLeft = data.time_left;
            timerElement.textContent = `Time Left: ${timeLeft}s`;
          }
          
          // Drawing data received
          if (data.hasOwnProperty('x1')) {
            const { x1, y1, x2, y2, color, brush_thickness, pixel_perc, power_up_id, client_id } = data;
            
            // Handle power-up collection
            if (power_up_id) {
              for (let i = 0; i < powerUpsAvailable.length; i++) {
                if (powerUpsAvailable[i].id === power_up_id) {
                  const powerUpType = powerUpsAvailable[i].type;
                  powerUpsAvailable.splice(i, 1);
                  
                  if (selfId === client_id) {
                    if (powerUpType === "paint_bucket") {
                      const x = Math.floor(Math.random() * 1160) + 50;
                      const y = Math.floor(Math.random() * 400) + 50;
                      drawingCtx.beginPath();
                      drawingCtx.arc(x, y, 100, 0, 2 * Math.PI);
                      drawingCtx.fillStyle = `rgb(${DRAW_COLOR[0]}, ${DRAW_COLOR[1]}, ${DRAW_COLOR[2]})`;
                      drawingCtx.fill();
                    }
                    
                    if (powerUpType === "paint_brush") {
                      applyPaintBrush();
                    }
                    
                    if (powerUpType === "eraser") {
                      applyEraser();
                    }
                    
                    if (powerUpType === "devil_face") {
                      applyDevilFace();
                    }
                  }
                  
                  break;
                }
              }
            }
            
            // Draw on canvas if it's not our own drawing (we'll handle our own drawing separately)
            if (client_id !== selfId) {
              drawingCtx.beginPath();
              drawingCtx.moveTo(x1, y1);
              drawingCtx.lineTo(x2, y2);
              drawingCtx.strokeStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
              drawingCtx.lineWidth = brush_thickness;
              drawingCtx.lineCap = 'round';
              drawingCtx.stroke();
            }
            
            // Update client data for score display
            const colorKey = `${color[0]},${color[1]},${color[2]}`;
            clientData[colorKey] = pixel_perc;
            updateScores();
          }
          
        } catch (error) {
          console.error("Error processing message:", error);
        }
      };
    }
    
    // Initialize WebSocket connection
    connectWebSocket();
    
    // Function to clear the drawing canvas
    function clearDrawingCanvas() {
      drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    }
    
    // Draw text helper
    function drawText(context, text, x, y, color, fontSize) {
      context.font = `${fontSize}px Arial`;
      context.fillStyle = color;
      context.fillText(text, x, y);
    }
    
    // Update scores display
    function updateScores() {
      let scoresHTML = "";
      let i = 0;
      
      for (const [colorStr, percentage] of Object.entries(clientData)) {
        const color = colorStr.split(",").map(Number);
        const colorCSS = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
        
        if (color[0] === DRAW_COLOR[0] && color[1] === DRAW_COLOR[1] && color[2] === DRAW_COLOR[2]) {
          scoresHTML += `<div style="color: ${colorCSS}; font-weight: bold; margin-bottom: 5px;">
                          YOU: ${percentage.toFixed(2)}%
                        </div>`;
        } else if (color[0] === 0 && color[1] === 0 && color[2] === 0) {
          // Skip black color
          continue;
        } else {
          scoresHTML += `<div style="color: ${colorCSS}; margin-bottom: 5px;">
                          Player (${color[0]}, ${color[1]}, ${color[2]}): ${percentage.toFixed(2)}%
                        </div>`;
        }
        i++;
      }
      
      playerScoresElement.innerHTML = scoresHTML;
    }
    
    // Function to check if index finger is up and others are down
    function isIndexFingerUp(landmarks) {
      // Get the y-coordinates of important finger landmarks
      const wristY = landmarks[0].y;
      const indexMCP = landmarks[5].y;
      const indexPIP = landmarks[6].y;
      const indexDIP = landmarks[7].y;
      const indexTip = landmarks[8].y;
      
      const middleMCP = landmarks[9].y;
      const middleTip = landmarks[12].y;
      
      const ringMCP = landmarks[13].y;
      const ringTip = landmarks[16].y;
      
      const pinkyMCP = landmarks[17].y;
      const pinkyTip = landmarks[20].y;
      
      const thumbTip = landmarks[4].y;
      
      // Check if index finger is extended up
      const isIndexUp = indexTip < indexDIP && indexDIP < indexPIP && indexPIP < indexMCP;
      
      // Check if other fingers are closed (tips below MCPs)
      const isMiddleClosed = middleTip > middleMCP;
      const isRingClosed = ringTip > ringMCP;
      const isPinkyClosed = pinkyTip > pinkyMCP;
      
      // For thumb we just check if it's generally higher than the wrist
      const isThumbNotUp = thumbTip > wristY;
      
      return isIndexUp && isMiddleClosed && isRingClosed && isPinkyClosed;
    }
    
    // Function to check if index and middle fingers are up (for selection)
    function isTwoFingersUp(landmarks) {
      const indexMCP = landmarks[5].y;
      const indexPIP = landmarks[6].y;
      const indexTIP = landmarks[8].y;
      
      const middleMCP = landmarks[9].y;
      const middlePIP = landmarks[10].y;
      const middleTIP = landmarks[12].y;
      
      const ringTIP = landmarks[16].y;
      const pinkyTIP = landmarks[20].y;
      
      // Check if index and middle fingers are up
      const isIndexUp = indexTIP < indexPIP && indexPIP < indexMCP;
      const isMiddleUp = middleTIP < middlePIP && middlePIP < middleMCP;
      
      // Check if other fingers are down
      const isRingDown = ringTIP > landmarks[13].y;
      const isPinkyDown = pinkyTIP > landmarks[17].y;
      
      return isIndexUp && isMiddleUp && isRingDown && isPinkyDown;
    }
    
    // Check if selection is in a specific area
    function isInArea(x, y, areaX, areaY, areaWidth, areaHeight) {
      return x >= areaX && x <= areaX + areaWidth && y >= areaY && y <= areaY + areaHeight;
    }
    
    // Check for power-up collection
    function checkPowerUpCollection(x, y) {
      for (let i = 0; i < powerUpsAvailable.length; i++) {
        const powerUp = powerUpsAvailable[i];
        if (Math.abs(x - powerUp.x) < 20 && Math.abs(y - powerUp.y) < 20) {
          return powerUp.id;
        }
      }
      return null;
    }
    
    // Calculate pixel percentage covered by a specific color
    async function getPixelPercent(color) {
      const imageData = drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height);
      const data = imageData.data;
      let matchingPixels = 0;
      const totalPixels = drawingCanvas.width * drawingCanvas.height;
      
      for (let i = 0; i < data.length; i += 4) {
        if (data[i] === color[0] && data[i + 1] === color[1] && data[i + 2] === color[2] && data[i + 3] !== 0) {
          matchingPixels++;
        }
      }
      
      return (matchingPixels / totalPixels) * 100;
    }
    
    // Send drawing data to server
    async function sendDrawData(x1, y1, x2, y2, powerUpId) {
      if (!websocket || websocket.readyState !== WebSocket.OPEN) return;
      
      const currentColor = DRAW_COLOR_TEMP || DRAW_COLOR;
      
      try {
        const data = {
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2,
          color: currentColor,
          brush_thickness: brushThickness,
          pixel_perc: await getPixelPercent(DRAW_COLOR),
          power_up_id: powerUpId,
          client_id: selfId
        };
        
        websocket.send(JSON.stringify(data));
      } catch (error) {
        console.error("Error sending draw data:", error);
      }
    }
    
    // Functions for power-ups
    function applyDevilFace() {
      const oldBrushThickness = brushThickness;
      brushThickness -= 24;
      setTimeout(() => {
        brushThickness = oldBrushThickness;
      }, 5000);
    }
    
    function applyPaintBrush() {
      const oldBrushThickness = brushThickness;
      brushThickness += 20;
      setTimeout(() => {
        brushThickness = oldBrushThickness;
      }, 5000);
    }
    
    function applyEraser() {
      const oldBrushThickness = brushThickness;
      brushThickness += 20;
      DRAW_COLOR_TEMP = [0, 0, 0];
      setTimeout(() => {
        DRAW_COLOR_TEMP = null;
        brushThickness = oldBrushThickness;
      }, 5000);
    }
    
    // Process hand landmarks and handle drawing
    function onResults(results) {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      
      // Draw the camera feed with mirrored view consistently
      canvasCtx.translate(canvasElement.width, 0);
      canvasCtx.scale(-1, 1);
      canvasCtx.drawImage(
          results.image, 0, 0, canvasElement.width, canvasElement.height);
      
      // Draw power-ups
      for (const powerUp of powerUpsAvailable) {
        // We would load and draw the power-up images here
        // For now, just drawing colored circles as placeholders
        canvasCtx.save();
        canvasCtx.translate(canvasElement.width, 0);
        canvasCtx.scale(-1, 1);
        canvasCtx.fillStyle = 'yellow';
        canvasCtx.beginPath();
        canvasCtx.arc(powerUp.x, powerUp.y, 15, 0, 2 * Math.PI);
        canvasCtx.fill();
        canvasCtx.restore();
      }
      
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        // Draw hand landmarks and connections
        for (const landmarks of results.multiHandLandmarks) {
          // Convert to flipped coordinate system for drawing
          canvasCtx.lineWidth = 0.5;
          drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS,
                       {color: 'rgba(255, 255, 255, 0.4)', lineWidth: 0.5});
          drawLandmarks(canvasCtx, landmarks, {
            color: 'rgba(255, 255, 255, 0.5)', 
            lineWidth: 0.5,
            radius: 2
          });
          
          // Get the tip of the index finger in the flipped coordinate system
          const indexTipX = landmarks[8].x * canvasElement.width;
          const indexTipY = landmarks[8].y * canvasElement.height;
          
          // Convert to unflipped coordinates for game logic
          const x1 = canvasElement.width - indexTipX; // Unflip the x coordinate
          const y1 = indexTipY; // y doesn't need to be flipped
          
          // Handle different game states
          if (!gameActive && !gameReset && !gameCountdown) {
            // Handle start game gesture
            if (isTwoFingersUp(landmarks)) {
              if (isInArea(x1, y1, 340, 300, 200, 100)) {
                // Send start game request
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                  websocket.send(JSON.stringify({ type: "start" }));
                }
              }
            }
          } else if (gameActive) {
            // Check for drawing gesture (index finger up, others down)
            if (isIndexFingerUp(landmarks)) {
              isDrawing = true;
              
              // Draw colored circle indicating drawing point
              canvasCtx.save();
              canvasCtx.translate(canvasElement.width, 0);
              canvasCtx.scale(-1, 1);
              canvasCtx.fillStyle = DRAW_COLOR_TEMP ? 
                                   `rgb(${DRAW_COLOR_TEMP[0]}, ${DRAW_COLOR_TEMP[1]}, ${DRAW_COLOR_TEMP[2]})` : 
                                   `rgb(${DRAW_COLOR[0]}, ${DRAW_COLOR[1]}, ${DRAW_COLOR[2]})`;
              canvasCtx.beginPath();
              canvasCtx.arc(indexTipX, indexTipY, 10, 0, 2 * Math.PI);
              canvasCtx.fill();
              canvasCtx.restore();
              
              // Check for power-up collection
              const powerUpId = checkPowerUpCollection(x1, y1);
              
              // Handle drawing
              if (xp === 0 && yp === 0) {
                xp = x1;
                yp = y1;
              }
              
              // Draw on the drawing canvas
              drawingCtx.beginPath();
              drawingCtx.moveTo(xp, yp);
              drawingCtx.lineTo(x1, y1);
              drawingCtx.strokeStyle = DRAW_COLOR_TEMP ? 
                                     `rgb(${DRAW_COLOR_TEMP[0]}, ${DRAW_COLOR_TEMP[1]}, ${DRAW_COLOR_TEMP[2]})` : 
                                     `rgb(${DRAW_COLOR[0]}, ${DRAW_COLOR[1]}, ${DRAW_COLOR[2]})`;
              drawingCtx.lineWidth = brushThickness;
              drawingCtx.lineCap = 'round';
              drawingCtx.stroke();
              
              // Send drawing data to server
              sendDrawData(xp, yp, x1, y1, powerUpId);
              
              // Update drawing position
              xp = x1;
              yp = y1;
            } else {
              // Reset drawing state when not drawing
              isDrawing = false;
              xp = 0;
              yp = 0;
            }
          } else if (gameReset) {
            // Handle reset game gesture
            if (isTwoFingersUp(landmarks)) {
              if (isInArea(x1, y1, 740, 300, 200, 100)) {
                // Send reset game request
                if (websocket && websocket.readyState === WebSocket.OPEN) {
                  websocket.send(JSON.stringify({ type: "reset" }));
                }
              }
            }
          }
        }
      }
      
      canvasCtx.restore();
    }
    
    // Set up MediaPipe Hands
    const hands = new Hands({locateFile: (file) => {
      return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.65,
      minTrackingConfidence: 0.5
    });
    
    hands.onResults(onResults);
    
    const camera = new Camera(videoElement, {
      onFrame: async () => {
        await hands.send({image: videoElement});
      },
      width: 1280,
      height: 720
    });
    
    // Function to clear the drawing canvas
    function clearCanvas() {
      drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    }
    
    // Start the camera
    camera.start();
</script>
</html>